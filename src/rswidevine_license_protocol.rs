// This file is @generated by prost-build.
/// LicenseIdentification is propagated from LicenseRequest to License,
/// incrementing version with each iteration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LicenseIdentification {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub session_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub purchase_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(enumeration = "LicenseType", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub version: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "6")]
    pub provider_session_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct License {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<LicenseIdentification>,
    #[prost(message, optional, tag = "2")]
    pub policy: ::core::option::Option<license::Policy>,
    #[prost(message, repeated, tag = "3")]
    pub key: ::prost::alloc::vec::Vec<license::KeyContainer>,
    /// Time of the request in seconds (UTC) as set in
    /// LicenseRequest.request_time.  If this time is not set in the request,
    /// the local time at the license service is used in this field.
    #[prost(int64, optional, tag = "4")]
    pub license_start_time: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "5", default = "false")]
    pub remote_attestation_verified: ::core::option::Option<bool>,
    /// Client token generated by the content provider. Optional.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub provider_client_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
    /// specification. Propagated from Widevine PSSH box. Optional.
    #[prost(uint32, optional, tag = "7")]
    pub protection_scheme: ::core::option::Option<u32>,
    /// 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
    /// HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
    /// depends on client max_hdcp_version).
    /// Additional details can be found in Widevine Modular DRM Security
    /// Integration Guide for CENC.
    #[prost(bytes = "vec", optional, tag = "8")]
    pub srm_requirement: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
    /// depending on client max_hdcp_version) that should be installed on the
    /// client device.
    #[prost(bytes = "vec", optional, tag = "9")]
    pub srm_update: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Indicates the status of any type of platform verification performed by the
    /// server.
    #[prost(
        enumeration = "PlatformVerificationStatus",
        optional,
        tag = "10",
        default = "PlatformNoVerification"
    )]
    pub platform_verification_status: ::core::option::Option<i32>,
    /// IDs of the groups for which keys are delivered in this license, if any.
    #[prost(bytes = "vec", repeated, tag = "11")]
    pub group_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `License`.
pub mod license {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Policy {
        /// Indicates that playback of the content is allowed.
        #[prost(bool, optional, tag = "1", default = "false")]
        pub can_play: ::core::option::Option<bool>,
        /// Indicates that the license may be persisted to non-volatile
        /// storage for offline use.
        #[prost(bool, optional, tag = "2", default = "false")]
        pub can_persist: ::core::option::Option<bool>,
        /// Indicates that renewal of this license is allowed.
        #[prost(bool, optional, tag = "3", default = "false")]
        pub can_renew: ::core::option::Option<bool>,
        /// Indicates the rental window.
        #[prost(int64, optional, tag = "4", default = "0")]
        pub rental_duration_seconds: ::core::option::Option<i64>,
        /// Indicates the viewing window, once playback has begun.
        #[prost(int64, optional, tag = "5", default = "0")]
        pub playback_duration_seconds: ::core::option::Option<i64>,
        /// Indicates the time window for this specific license.
        #[prost(int64, optional, tag = "6", default = "0")]
        pub license_duration_seconds: ::core::option::Option<i64>,
        /// The window of time, in which playback is allowed to continue while
        /// renewal is attempted, yet unsuccessful due to backend problems with
        /// the license server.
        #[prost(int64, optional, tag = "7", default = "0")]
        pub renewal_recovery_duration_seconds: ::core::option::Option<i64>,
        /// All renewal requests for this license shall be directed to the
        /// specified URL.
        #[prost(string, optional, tag = "8")]
        pub renewal_server_url: ::core::option::Option<::prost::alloc::string::String>,
        /// How many seconds after license_start_time, before renewal is first
        /// attempted.
        #[prost(int64, optional, tag = "9", default = "0")]
        pub renewal_delay_seconds: ::core::option::Option<i64>,
        /// Specifies the delay in seconds between subsequent license
        /// renewal requests, in case of failure.
        #[prost(int64, optional, tag = "10", default = "0")]
        pub renewal_retry_interval_seconds: ::core::option::Option<i64>,
        /// Indicates that the license shall be sent for renewal when usage is
        /// started.
        #[prost(bool, optional, tag = "11", default = "false")]
        pub renew_with_usage: ::core::option::Option<bool>,
        /// Indicates to client that license renewal and release requests ought to
        /// include ClientIdentification (client_id).
        #[prost(bool, optional, tag = "12", default = "false")]
        pub always_include_client_id: ::core::option::Option<bool>,
        /// Duration of grace period before playback_duration_seconds (short window)
        /// goes into effect. Optional.
        #[prost(int64, optional, tag = "13", default = "0")]
        pub play_start_grace_period_seconds: ::core::option::Option<i64>,
        /// Enables "soft enforcement" of playback_duration_seconds, letting the user
        /// finish playback even if short window expires. Optional.
        #[prost(bool, optional, tag = "14", default = "false")]
        pub soft_enforce_playback_duration: ::core::option::Option<bool>,
        /// Enables "soft enforcement" of rental_duration_seconds. Initial playback
        /// must always start before rental duration expires.  In order to allow
        /// subsequent playbacks to start after the rental duration expires,
        /// soft_enforce_playback_duration must be true. Otherwise, subsequent
        /// playbacks will not be allowed once rental duration expires. Optional.
        #[prost(bool, optional, tag = "15", default = "true")]
        pub soft_enforce_rental_duration: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyContainer {
        #[prost(bytes = "vec", optional, tag = "1")]
        pub id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes = "vec", optional, tag = "3")]
        pub key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(enumeration = "key_container::KeyType", optional, tag = "4")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(
            enumeration = "key_container::SecurityLevel",
            optional,
            tag = "5",
            default = "SwSecureCrypto"
        )]
        pub level: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "6")]
        pub required_protection: ::core::option::Option<key_container::OutputProtection>,
        /// NOTE: Use of requested_protection is not recommended as it is only
        /// supported on a small number of platforms.
        #[prost(message, optional, tag = "7")]
        pub requested_protection: ::core::option::Option<
            key_container::OutputProtection,
        >,
        #[prost(message, optional, tag = "8")]
        pub key_control: ::core::option::Option<key_container::KeyControl>,
        #[prost(message, optional, tag = "9")]
        pub operator_session_key_permissions: ::core::option::Option<
            key_container::OperatorSessionKeyPermissions,
        >,
        /// Optional video resolution constraints. If the video resolution of the
        /// content being decrypted/decoded falls within one of the specified ranges,
        /// the optional required_protections may be applied. Otherwise an error will
        /// be reported.
        /// NOTE: Use of this feature is not recommended, as it is only supported on
        /// a small number of platforms.
        #[prost(message, repeated, tag = "10")]
        pub video_resolution_constraints: ::prost::alloc::vec::Vec<
            key_container::VideoResolutionConstraint,
        >,
        /// Optional flag to indicate the key must only be used if the client
        /// supports anti rollback of the user table.  Content provider can query the
        /// client capabilities to determine if the client support this feature.
        #[prost(bool, optional, tag = "11", default = "false")]
        pub anti_rollback_usage_table: ::core::option::Option<bool>,
        /// Optional not limited to commonly known track types such as SD, HD.
        /// It can be some provider defined label to identify the track.
        #[prost(string, optional, tag = "12")]
        pub track_label: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `KeyContainer`.
    pub mod key_container {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct KeyControl {
            /// |key_control| is documented in:
            /// Widevine Modular DRM Security Integration Guide for CENC
            /// If present, the key control must be communicated to the secure
            /// environment prior to any usage. This message is automatically generated
            /// by the Widevine License Server SDK.
            #[prost(bytes = "vec", optional, tag = "1")]
            pub key_control_block: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
            #[prost(bytes = "vec", optional, tag = "2")]
            pub iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct OutputProtection {
            #[prost(
                enumeration = "output_protection::Hdcp",
                optional,
                tag = "1",
                default = "None"
            )]
            pub hdcp: ::core::option::Option<i32>,
            #[prost(
                enumeration = "output_protection::Cgms",
                optional,
                tag = "2",
                default = "None"
            )]
            pub cgms_flags: ::core::option::Option<i32>,
            #[prost(
                enumeration = "output_protection::HdcpSrmRule",
                optional,
                tag = "3",
                default = "None"
            )]
            pub hdcp_srm_rule: ::core::option::Option<i32>,
            /// Optional requirement to indicate analog output is not allowed.
            #[prost(bool, optional, tag = "4", default = "false")]
            pub disable_analog_output: ::core::option::Option<bool>,
            /// Optional requirement to indicate digital output is not allowed.
            #[prost(bool, optional, tag = "5", default = "false")]
            pub disable_digital_output: ::core::option::Option<bool>,
        }
        /// Nested message and enum types in `OutputProtection`.
        pub mod output_protection {
            /// Indicates whether HDCP is required on digital outputs, and which
            /// version should be used.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Hdcp {
                None = 0,
                V1 = 1,
                V2 = 2,
                V21 = 3,
                V22 = 4,
                V23 = 5,
                NoDigitalOutput = 255,
            }
            impl Hdcp {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::None => "HDCP_NONE",
                        Self::V1 => "HDCP_V1",
                        Self::V2 => "HDCP_V2",
                        Self::V21 => "HDCP_V2_1",
                        Self::V22 => "HDCP_V2_2",
                        Self::V23 => "HDCP_V2_3",
                        Self::NoDigitalOutput => "HDCP_NO_DIGITAL_OUTPUT",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "HDCP_NONE" => Some(Self::None),
                        "HDCP_V1" => Some(Self::V1),
                        "HDCP_V2" => Some(Self::V2),
                        "HDCP_V2_1" => Some(Self::V21),
                        "HDCP_V2_2" => Some(Self::V22),
                        "HDCP_V2_3" => Some(Self::V23),
                        "HDCP_NO_DIGITAL_OUTPUT" => Some(Self::NoDigitalOutput),
                        _ => None,
                    }
                }
            }
            /// Indicate the CGMS setting to be inserted on analog output.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Cgms {
                None = 42,
                CopyFree = 0,
                CopyOnce = 2,
                CopyNever = 3,
            }
            impl Cgms {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::None => "CGMS_NONE",
                        Self::CopyFree => "COPY_FREE",
                        Self::CopyOnce => "COPY_ONCE",
                        Self::CopyNever => "COPY_NEVER",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "CGMS_NONE" => Some(Self::None),
                        "COPY_FREE" => Some(Self::CopyFree),
                        "COPY_ONCE" => Some(Self::CopyOnce),
                        "COPY_NEVER" => Some(Self::CopyNever),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum HdcpSrmRule {
                None = 0,
                /// In 'required_protection', this means most current SRM is required.
                /// Update the SRM on the device. If update cannot happen,
                /// do not allow the key.
                /// In 'requested_protection', this means most current SRM is requested.
                /// Update the SRM on the device. If update cannot happen,
                /// allow use of the key anyway.
                CurrentSrm = 1,
            }
            impl HdcpSrmRule {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::None => "HDCP_SRM_RULE_NONE",
                        Self::CurrentSrm => "CURRENT_SRM",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "HDCP_SRM_RULE_NONE" => Some(Self::None),
                        "CURRENT_SRM" => Some(Self::CurrentSrm),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct VideoResolutionConstraint {
            /// Minimum and maximum video resolutions in the range (height x width).
            #[prost(uint32, optional, tag = "1")]
            pub min_resolution_pixels: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag = "2")]
            pub max_resolution_pixels: ::core::option::Option<u32>,
            /// Optional output protection requirements for this range. If not
            /// specified, the OutputProtection in the KeyContainer applies.
            #[prost(message, optional, tag = "3")]
            pub required_protection: ::core::option::Option<OutputProtection>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct OperatorSessionKeyPermissions {
            /// Permissions/key usage flags for operator service keys
            /// (type = OPERATOR_SESSION).
            #[prost(bool, optional, tag = "1", default = "false")]
            pub allow_encrypt: ::core::option::Option<bool>,
            #[prost(bool, optional, tag = "2", default = "false")]
            pub allow_decrypt: ::core::option::Option<bool>,
            #[prost(bool, optional, tag = "3", default = "false")]
            pub allow_sign: ::core::option::Option<bool>,
            #[prost(bool, optional, tag = "4", default = "false")]
            pub allow_signature_verify: ::core::option::Option<bool>,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum KeyType {
            /// Exactly one key of this type must appear.
            Signing = 1,
            /// Content key.
            Content = 2,
            /// Key control block for license renewals. No key.
            KeyControl = 3,
            /// wrapped keys for auxiliary crypto operations.
            OperatorSession = 4,
            /// Entitlement keys.
            Entitlement = 5,
            /// Partner-specific content key.
            OemContent = 6,
        }
        impl KeyType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Signing => "SIGNING",
                    Self::Content => "CONTENT",
                    Self::KeyControl => "KEY_CONTROL",
                    Self::OperatorSession => "OPERATOR_SESSION",
                    Self::Entitlement => "ENTITLEMENT",
                    Self::OemContent => "OEM_CONTENT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SIGNING" => Some(Self::Signing),
                    "CONTENT" => Some(Self::Content),
                    "KEY_CONTROL" => Some(Self::KeyControl),
                    "OPERATOR_SESSION" => Some(Self::OperatorSession),
                    "ENTITLEMENT" => Some(Self::Entitlement),
                    "OEM_CONTENT" => Some(Self::OemContent),
                    _ => None,
                }
            }
        }
        /// The SecurityLevel enumeration allows the server to communicate the level
        /// of robustness required by the client, in order to use the key.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SecurityLevel {
            /// Software-based whitebox crypto is required.
            SwSecureCrypto = 1,
            /// Software crypto and an obfuscated decoder is required.
            SwSecureDecode = 2,
            /// The key material and crypto operations must be performed within a
            /// hardware backed trusted execution environment.
            HwSecureCrypto = 3,
            /// The crypto and decoding of content must be performed within a hardware
            /// backed trusted execution environment.
            HwSecureDecode = 4,
            /// The crypto, decoding and all handling of the media (compressed and
            /// uncompressed) must be handled within a hardware backed trusted
            /// execution environment.
            HwSecureAll = 5,
        }
        impl SecurityLevel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::SwSecureCrypto => "SW_SECURE_CRYPTO",
                    Self::SwSecureDecode => "SW_SECURE_DECODE",
                    Self::HwSecureCrypto => "HW_SECURE_CRYPTO",
                    Self::HwSecureDecode => "HW_SECURE_DECODE",
                    Self::HwSecureAll => "HW_SECURE_ALL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SW_SECURE_CRYPTO" => Some(Self::SwSecureCrypto),
                    "SW_SECURE_DECODE" => Some(Self::SwSecureDecode),
                    "HW_SECURE_CRYPTO" => Some(Self::HwSecureCrypto),
                    "HW_SECURE_DECODE" => Some(Self::HwSecureDecode),
                    "HW_SECURE_ALL" => Some(Self::HwSecureAll),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LicenseRequest {
    /// The client_id provides information authenticating the calling device.  It
    /// contains the Widevine keybox token that was installed on the device at the
    /// factory.  This field or encrypted_client_id below is required for a valid
    /// license request, but both should never be present in the same request.
    #[prost(message, optional, tag = "1")]
    pub client_id: ::core::option::Option<ClientIdentification>,
    #[prost(message, optional, tag = "2")]
    pub content_id: ::core::option::Option<license_request::ContentIdentification>,
    #[prost(enumeration = "license_request::RequestType", optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
    /// Time of the request in seconds (UTC) as set by the client.
    #[prost(int64, optional, tag = "4")]
    pub request_time: ::core::option::Option<i64>,
    /// Old-style decimal-encoded string key control nonce.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub key_control_nonce_deprecated: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(enumeration = "ProtocolVersion", optional, tag = "6", default = "Version20")]
    pub protocol_version: ::core::option::Option<i32>,
    /// New-style uint32 key control nonce, please use instead of
    /// key_control_nonce_deprecated.
    #[prost(uint32, optional, tag = "7")]
    pub key_control_nonce: ::core::option::Option<u32>,
    /// Encrypted ClientIdentification message, used for privacy purposes.
    #[prost(message, optional, tag = "8")]
    pub encrypted_client_id: ::core::option::Option<EncryptedClientIdentification>,
}
/// Nested message and enum types in `LicenseRequest`.
pub mod license_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContentIdentification {
        #[prost(oneof = "content_identification::ContentIdVariant", tags = "1, 2, 3, 4")]
        pub content_id_variant: ::core::option::Option<
            content_identification::ContentIdVariant,
        >,
    }
    /// Nested message and enum types in `ContentIdentification`.
    pub mod content_identification {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct WidevinePsshData {
            #[prost(bytes = "vec", repeated, tag = "1")]
            pub pssh_data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
            #[prost(enumeration = "super::super::LicenseType", optional, tag = "2")]
            pub license_type: ::core::option::Option<i32>,
            /// Opaque, client-specified.
            #[prost(bytes = "vec", optional, tag = "3")]
            pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct WebmKeyId {
            #[prost(bytes = "vec", optional, tag = "1")]
            pub header: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
            #[prost(enumeration = "super::super::LicenseType", optional, tag = "2")]
            pub license_type: ::core::option::Option<i32>,
            /// Opaque, client-specified.
            #[prost(bytes = "vec", optional, tag = "3")]
            pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ExistingLicense {
            #[prost(message, optional, tag = "1")]
            pub license_id: ::core::option::Option<super::super::LicenseIdentification>,
            #[prost(int64, optional, tag = "2")]
            pub seconds_since_started: ::core::option::Option<i64>,
            #[prost(int64, optional, tag = "3")]
            pub seconds_since_last_played: ::core::option::Option<i64>,
            #[prost(bytes = "vec", optional, tag = "4")]
            pub session_usage_table_entry: ::core::option::Option<
                ::prost::alloc::vec::Vec<u8>,
            >,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct InitData {
            #[prost(
                enumeration = "init_data::InitDataType",
                optional,
                tag = "1",
                default = "Cenc"
            )]
            pub init_data_type: ::core::option::Option<i32>,
            #[prost(bytes = "vec", optional, tag = "2")]
            pub init_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
            #[prost(enumeration = "super::super::LicenseType", optional, tag = "3")]
            pub license_type: ::core::option::Option<i32>,
            #[prost(bytes = "vec", optional, tag = "4")]
            pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
        /// Nested message and enum types in `InitData`.
        pub mod init_data {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum InitDataType {
                Cenc = 1,
                Webm = 2,
            }
            impl InitDataType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Cenc => "CENC",
                        Self::Webm => "WEBM",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "CENC" => Some(Self::Cenc),
                        "WEBM" => Some(Self::Webm),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ContentIdVariant {
            /// Exactly one of these must be present.
            #[prost(message, tag = "1")]
            WidevinePsshData(WidevinePsshData),
            #[prost(message, tag = "2")]
            WebmKeyId(WebmKeyId),
            #[prost(message, tag = "3")]
            ExistingLicense(ExistingLicense),
            #[prost(message, tag = "4")]
            InitData(InitData),
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RequestType {
        New = 1,
        Renewal = 2,
        Release = 3,
    }
    impl RequestType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::New => "NEW",
                Self::Renewal => "RENEWAL",
                Self::Release => "RELEASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NEW" => Some(Self::New),
                "RENEWAL" => Some(Self::Renewal),
                "RELEASE" => Some(Self::Release),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricData {
    /// 'stage' that is currently processing the SignedMessage.  Required.
    #[prost(string, optional, tag = "1")]
    pub stage_name: ::core::option::Option<::prost::alloc::string::String>,
    /// metric and associated value.
    #[prost(message, repeated, tag = "2")]
    pub metric_data: ::prost::alloc::vec::Vec<metric_data::TypeValue>,
}
/// Nested message and enum types in `MetricData`.
pub mod metric_data {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TypeValue {
        #[prost(enumeration = "MetricType", optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        /// The value associated with 'type'.  For example if type == LATENCY, the
        /// value would be the time in microseconds spent in this 'stage'.
        #[prost(int64, optional, tag = "2", default = "0")]
        pub value: ::core::option::Option<i64>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetricType {
        /// The time spent in the 'stage', specified in microseconds.
        Latency = 1,
        /// The UNIX epoch timestamp at which the 'stage' was first accessed in
        /// microseconds.
        Timestamp = 2,
    }
    impl MetricType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Latency => "LATENCY",
                Self::Timestamp => "TIMESTAMP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LATENCY" => Some(Self::Latency),
                "TIMESTAMP" => Some(Self::Timestamp),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionInfo {
    /// License SDK version reported by the Widevine License SDK. This field
    /// is populated automatically by the SDK.
    #[prost(string, optional, tag = "1")]
    pub license_sdk_version: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the service hosting the license SDK. This field is optional.
    /// It may be provided by the hosting service.
    #[prost(string, optional, tag = "2")]
    pub license_service_version: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedMessage {
    #[prost(enumeration = "signed_message::MessageType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub msg: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Required field that contains the signature of the bytes of msg.
    /// For license requests, the signing algorithm is determined by the
    /// certificate contained in the request.
    /// For license responses, the signing algorithm is HMAC with signing key based
    /// on |session_key|.
    #[prost(bytes = "vec", optional, tag = "3")]
    pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// If populated, the contents of this field will be signaled by the
    /// |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
    /// key is the bytes of an encrypted AES key. If the |session_key_type| is
    /// EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
    /// serialized ECC public key.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub session_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Remote attestation data which will be present in the initial license
    /// request for ChromeOS client devices operating in verified mode. Remote
    /// attestation challenge data is |msg| field above. Optional.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub remote_attestation: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "6")]
    pub metric_data: ::prost::alloc::vec::Vec<MetricData>,
    /// Version information from the SDK and license service. This information is
    /// provided in the license response.
    #[prost(message, optional, tag = "7")]
    pub service_version_info: ::core::option::Option<VersionInfo>,
    /// Optional field that contains the algorithm type used to generate the
    /// session_key and signature in a LICENSE message.
    #[prost(
        enumeration = "signed_message::SessionKeyType",
        optional,
        tag = "8",
        default = "WrappedAesKey"
    )]
    pub session_key_type: ::core::option::Option<i32>,
    /// The core message is the simple serialization of fields used by OEMCrypto.
    /// This field was introduced in OEMCrypto API v16.
    #[prost(bytes = "vec", optional, tag = "9")]
    pub oemcrypto_core_message: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `SignedMessage`.
pub mod signed_message {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessageType {
        LicenseRequest = 1,
        License = 2,
        ErrorResponse = 3,
        ServiceCertificateRequest = 4,
        ServiceCertificate = 5,
        SubLicense = 6,
        CasLicenseRequest = 7,
        CasLicense = 8,
        ExternalLicenseRequest = 9,
        ExternalLicense = 10,
    }
    impl MessageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::LicenseRequest => "LICENSE_REQUEST",
                Self::License => "LICENSE",
                Self::ErrorResponse => "ERROR_RESPONSE",
                Self::ServiceCertificateRequest => "SERVICE_CERTIFICATE_REQUEST",
                Self::ServiceCertificate => "SERVICE_CERTIFICATE",
                Self::SubLicense => "SUB_LICENSE",
                Self::CasLicenseRequest => "CAS_LICENSE_REQUEST",
                Self::CasLicense => "CAS_LICENSE",
                Self::ExternalLicenseRequest => "EXTERNAL_LICENSE_REQUEST",
                Self::ExternalLicense => "EXTERNAL_LICENSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LICENSE_REQUEST" => Some(Self::LicenseRequest),
                "LICENSE" => Some(Self::License),
                "ERROR_RESPONSE" => Some(Self::ErrorResponse),
                "SERVICE_CERTIFICATE_REQUEST" => Some(Self::ServiceCertificateRequest),
                "SERVICE_CERTIFICATE" => Some(Self::ServiceCertificate),
                "SUB_LICENSE" => Some(Self::SubLicense),
                "CAS_LICENSE_REQUEST" => Some(Self::CasLicenseRequest),
                "CAS_LICENSE" => Some(Self::CasLicense),
                "EXTERNAL_LICENSE_REQUEST" => Some(Self::ExternalLicenseRequest),
                "EXTERNAL_LICENSE" => Some(Self::ExternalLicense),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SessionKeyType {
        Undefined = 0,
        WrappedAesKey = 1,
        EphermeralEccPublicKey = 2,
    }
    impl SessionKeyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::WrappedAesKey => "WRAPPED_AES_KEY",
                Self::EphermeralEccPublicKey => "EPHERMERAL_ECC_PUBLIC_KEY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "WRAPPED_AES_KEY" => Some(Self::WrappedAesKey),
                "EPHERMERAL_ECC_PUBLIC_KEY" => Some(Self::EphermeralEccPublicKey),
                _ => None,
            }
        }
    }
}
/// ClientIdentification message used to authenticate the client device.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientIdentification {
    /// Type of factory-provisioned device root of trust. Optional.
    #[prost(
        enumeration = "client_identification::TokenType",
        optional,
        tag = "1",
        default = "Keybox"
    )]
    pub r#type: ::core::option::Option<i32>,
    /// Factory-provisioned device root of trust. Required.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Optional client information name/value pairs.
    #[prost(message, repeated, tag = "3")]
    pub client_info: ::prost::alloc::vec::Vec<client_identification::NameValue>,
    /// Client token generated by the content provider. Optional.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub provider_client_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Number of licenses received by the client to which the token above belongs.
    /// Only present if client_token is specified.
    #[prost(uint32, optional, tag = "5")]
    pub license_counter: ::core::option::Option<u32>,
    /// List of non-baseline client capabilities.
    #[prost(message, optional, tag = "6")]
    pub client_capabilities: ::core::option::Option<
        client_identification::ClientCapabilities,
    >,
    /// Serialized VmpData message. Optional.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub vmp_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Optional field that may contain additional provisioning credentials.
    #[prost(message, repeated, tag = "8")]
    pub device_credentials: ::prost::alloc::vec::Vec<
        client_identification::ClientCredentials,
    >,
}
/// Nested message and enum types in `ClientIdentification`.
pub mod client_identification {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NameValue {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Capabilities which not all clients may support. Used for the license
    /// exchange protocol only.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClientCapabilities {
        #[prost(bool, optional, tag = "1", default = "false")]
        pub client_token: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "2", default = "false")]
        pub session_token: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "3", default = "false")]
        pub video_resolution_constraints: ::core::option::Option<bool>,
        #[prost(
            enumeration = "client_capabilities::HdcpVersion",
            optional,
            tag = "4",
            default = "HdcpNone"
        )]
        pub max_hdcp_version: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "5")]
        pub oem_crypto_api_version: ::core::option::Option<u32>,
        /// Client has hardware support for protecting the usage table, such as
        /// storing the generation number in secure memory.  For Details, see:
        /// Widevine Modular DRM Security Integration Guide for CENC
        #[prost(bool, optional, tag = "6", default = "false")]
        pub anti_rollback_usage_table: ::core::option::Option<bool>,
        /// The client shall report |srm_version| if available.
        #[prost(uint32, optional, tag = "7")]
        pub srm_version: ::core::option::Option<u32>,
        /// A device may have SRM data, and report a version, but may not be capable
        /// of updating SRM data.
        #[prost(bool, optional, tag = "8", default = "false")]
        pub can_update_srm: ::core::option::Option<bool>,
        #[prost(
            enumeration = "client_capabilities::CertificateKeyType",
            repeated,
            packed = "false",
            tag = "9"
        )]
        pub supported_certificate_key_type: ::prost::alloc::vec::Vec<i32>,
        #[prost(
            enumeration = "client_capabilities::AnalogOutputCapabilities",
            optional,
            tag = "10",
            default = "AnalogOutputUnknown"
        )]
        pub analog_output_capabilities: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "11", default = "false")]
        pub can_disable_analog_output: ::core::option::Option<bool>,
        /// Clients can indicate a performance level supported by OEMCrypto.
        /// This will allow applications and providers to choose an appropriate
        /// quality of content to serve. Currently defined tiers are
        /// 1 (low), 2 (medium) and 3 (high). Any other value indicates that
        /// the resource rating is unavailable or reporting erroneous values
        /// for that device. For details see,
        /// Widevine Modular DRM Security Integration Guide for CENC
        #[prost(uint32, optional, tag = "12", default = "0")]
        pub resource_rating_tier: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `ClientCapabilities`.
    pub mod client_capabilities {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum HdcpVersion {
            HdcpNone = 0,
            HdcpV1 = 1,
            HdcpV2 = 2,
            HdcpV21 = 3,
            HdcpV22 = 4,
            HdcpV23 = 5,
            HdcpNoDigitalOutput = 255,
        }
        impl HdcpVersion {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::HdcpNone => "HDCP_NONE",
                    Self::HdcpV1 => "HDCP_V1",
                    Self::HdcpV2 => "HDCP_V2",
                    Self::HdcpV21 => "HDCP_V2_1",
                    Self::HdcpV22 => "HDCP_V2_2",
                    Self::HdcpV23 => "HDCP_V2_3",
                    Self::HdcpNoDigitalOutput => "HDCP_NO_DIGITAL_OUTPUT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "HDCP_NONE" => Some(Self::HdcpNone),
                    "HDCP_V1" => Some(Self::HdcpV1),
                    "HDCP_V2" => Some(Self::HdcpV2),
                    "HDCP_V2_1" => Some(Self::HdcpV21),
                    "HDCP_V2_2" => Some(Self::HdcpV22),
                    "HDCP_V2_3" => Some(Self::HdcpV23),
                    "HDCP_NO_DIGITAL_OUTPUT" => Some(Self::HdcpNoDigitalOutput),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum CertificateKeyType {
            Rsa2048 = 0,
            Rsa3072 = 1,
            EccSecp256r1 = 2,
            EccSecp384r1 = 3,
            EccSecp521r1 = 4,
        }
        impl CertificateKeyType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Rsa2048 => "RSA_2048",
                    Self::Rsa3072 => "RSA_3072",
                    Self::EccSecp256r1 => "ECC_SECP256R1",
                    Self::EccSecp384r1 => "ECC_SECP384R1",
                    Self::EccSecp521r1 => "ECC_SECP521R1",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "RSA_2048" => Some(Self::Rsa2048),
                    "RSA_3072" => Some(Self::Rsa3072),
                    "ECC_SECP256R1" => Some(Self::EccSecp256r1),
                    "ECC_SECP384R1" => Some(Self::EccSecp384r1),
                    "ECC_SECP521R1" => Some(Self::EccSecp521r1),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AnalogOutputCapabilities {
            AnalogOutputUnknown = 0,
            AnalogOutputNone = 1,
            AnalogOutputSupported = 2,
            AnalogOutputSupportsCgmsA = 3,
        }
        impl AnalogOutputCapabilities {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::AnalogOutputUnknown => "ANALOG_OUTPUT_UNKNOWN",
                    Self::AnalogOutputNone => "ANALOG_OUTPUT_NONE",
                    Self::AnalogOutputSupported => "ANALOG_OUTPUT_SUPPORTED",
                    Self::AnalogOutputSupportsCgmsA => "ANALOG_OUTPUT_SUPPORTS_CGMS_A",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ANALOG_OUTPUT_UNKNOWN" => Some(Self::AnalogOutputUnknown),
                    "ANALOG_OUTPUT_NONE" => Some(Self::AnalogOutputNone),
                    "ANALOG_OUTPUT_SUPPORTED" => Some(Self::AnalogOutputSupported),
                    "ANALOG_OUTPUT_SUPPORTS_CGMS_A" => {
                        Some(Self::AnalogOutputSupportsCgmsA)
                    }
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClientCredentials {
        #[prost(enumeration = "TokenType", optional, tag = "1", default = "Keybox")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TokenType {
        Keybox = 0,
        DrmDeviceCertificate = 1,
        RemoteAttestationCertificate = 2,
        OemDeviceCertificate = 3,
    }
    impl TokenType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Keybox => "KEYBOX",
                Self::DrmDeviceCertificate => "DRM_DEVICE_CERTIFICATE",
                Self::RemoteAttestationCertificate => "REMOTE_ATTESTATION_CERTIFICATE",
                Self::OemDeviceCertificate => "OEM_DEVICE_CERTIFICATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KEYBOX" => Some(Self::Keybox),
                "DRM_DEVICE_CERTIFICATE" => Some(Self::DrmDeviceCertificate),
                "REMOTE_ATTESTATION_CERTIFICATE" => {
                    Some(Self::RemoteAttestationCertificate)
                }
                "OEM_DEVICE_CERTIFICATE" => Some(Self::OemDeviceCertificate),
                _ => None,
            }
        }
    }
}
/// EncryptedClientIdentification message used to hold ClientIdentification
/// messages encrypted for privacy purposes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptedClientIdentification {
    /// Provider ID for which the ClientIdentifcation is encrypted (owner of
    /// service certificate).
    #[prost(string, optional, tag = "1")]
    pub provider_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Serial number for the service certificate for which ClientIdentification is
    /// encrypted.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub service_certificate_serial_number: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// Serialized ClientIdentification message, encrypted with the privacy key
    /// using AES-128-CBC with PKCS#5 padding.
    #[prost(bytes = "vec", optional, tag = "3")]
    pub encrypted_client_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Initialization vector needed to decrypt encrypted_client_id.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub encrypted_client_id_iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub encrypted_privacy_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// DRM certificate definition for user devices, intermediate, service, and root
/// certificates.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DrmCertificate {
    /// Type of certificate. Required.
    #[prost(enumeration = "drm_certificate::Type", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// 128-bit globally unique serial number of certificate.
    /// Value is 0 for root certificate. Required.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub serial_number: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// POSIX time, in seconds, when the certificate was created. Required.
    #[prost(uint32, optional, tag = "3")]
    pub creation_time_seconds: ::core::option::Option<u32>,
    /// POSIX time, in seconds, when the certificate should expire. Value of zero
    /// denotes indefinite expiry time. For more information on limited lifespan
    /// DRM certificates see (go/limited-lifespan-drm-certificates).
    #[prost(uint32, optional, tag = "12")]
    pub expiration_time_seconds: ::core::option::Option<u32>,
    /// Device public key. PKCS#1 ASN.1 DER-encoded. Required.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Widevine system ID for the device. Required for intermediate and
    /// user device certificates.
    #[prost(uint32, optional, tag = "5")]
    pub system_id: ::core::option::Option<u32>,
    /// Deprecated field, which used to indicate whether the device was a test
    /// (non-production) device. The test_device field in ProvisionedDeviceInfo
    /// below should be observed instead.
    #[deprecated]
    #[prost(bool, optional, tag = "6")]
    pub test_device_deprecated: ::core::option::Option<bool>,
    /// Service identifier (web origin) for the provider which owns the
    /// certificate. Required for service and provisioner certificates.
    #[prost(string, optional, tag = "7")]
    pub provider_id: ::core::option::Option<::prost::alloc::string::String>,
    /// This field is used only when type = SERVICE to specify which SDK uses
    /// service certificate. This repeated field is treated as a set. A certificate
    /// may be used for the specified service SDK if the appropriate ServiceType
    /// is specified in this field.
    #[prost(
        enumeration = "drm_certificate::ServiceType",
        repeated,
        packed = "false",
        tag = "8"
    )]
    pub service_types: ::prost::alloc::vec::Vec<i32>,
    /// Required. The algorithm field contains the curve used to create the
    /// |public_key| if algorithm is one of the ECC types.
    /// The |algorithm| is used for both to determine the if the certificate is ECC
    /// or RSA. The |algorithm| also specifies the parameters that were used to
    /// create |public_key| and are used to create an ephemeral session key.
    #[prost(
        enumeration = "drm_certificate::Algorithm",
        optional,
        tag = "9",
        default = "Rsa"
    )]
    pub algorithm: ::core::option::Option<i32>,
    /// Optional. May be present in DEVICE certificate types. This is the root
    /// of trust identifier that holds an encrypted value that identifies the
    /// keybox or other root of trust that was used to provision a DEVICE drm
    /// certificate.
    #[prost(bytes = "vec", optional, tag = "10")]
    pub rot_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Optional. May be present in devices that explicitly support dual keys. When
    /// present the |public_key| is used for verification of received license
    /// request messages.
    #[prost(message, optional, tag = "11")]
    pub encryption_key: ::core::option::Option<drm_certificate::EncryptionKey>,
}
/// Nested message and enum types in `DrmCertificate`.
pub mod drm_certificate {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EncryptionKey {
        /// Device public key. PKCS#1 ASN.1 DER-encoded. Required.
        #[prost(bytes = "vec", optional, tag = "1")]
        pub public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        /// Required. The algorithm field contains the curve used to create the
        /// |public_key| if algorithm is one of the ECC types.
        /// The |algorithm| is used for both to determine the if the certificate is
        /// ECC or RSA. The |algorithm| also specifies the parameters that were used
        /// to create |public_key| and are used to create an ephemeral session key.
        #[prost(enumeration = "Algorithm", optional, tag = "2", default = "Rsa")]
        pub algorithm: ::core::option::Option<i32>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// ProtoBestPractices: ignore.
        Root = 0,
        DeviceModel = 1,
        Device = 2,
        Service = 3,
        Provisioner = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Root => "ROOT",
                Self::DeviceModel => "DEVICE_MODEL",
                Self::Device => "DEVICE",
                Self::Service => "SERVICE",
                Self::Provisioner => "PROVISIONER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROOT" => Some(Self::Root),
                "DEVICE_MODEL" => Some(Self::DeviceModel),
                "DEVICE" => Some(Self::Device),
                "SERVICE" => Some(Self::Service),
                "PROVISIONER" => Some(Self::Provisioner),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ServiceType {
        UnknownServiceType = 0,
        LicenseServerSdk = 1,
        LicenseServerProxySdk = 2,
        ProvisioningSdk = 3,
        CasProxySdk = 4,
    }
    impl ServiceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownServiceType => "UNKNOWN_SERVICE_TYPE",
                Self::LicenseServerSdk => "LICENSE_SERVER_SDK",
                Self::LicenseServerProxySdk => "LICENSE_SERVER_PROXY_SDK",
                Self::ProvisioningSdk => "PROVISIONING_SDK",
                Self::CasProxySdk => "CAS_PROXY_SDK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_SERVICE_TYPE" => Some(Self::UnknownServiceType),
                "LICENSE_SERVER_SDK" => Some(Self::LicenseServerSdk),
                "LICENSE_SERVER_PROXY_SDK" => Some(Self::LicenseServerProxySdk),
                "PROVISIONING_SDK" => Some(Self::ProvisioningSdk),
                "CAS_PROXY_SDK" => Some(Self::CasProxySdk),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Algorithm {
        UnknownAlgorithm = 0,
        Rsa = 1,
        EccSecp256r1 = 2,
        EccSecp384r1 = 3,
        EccSecp521r1 = 4,
    }
    impl Algorithm {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownAlgorithm => "UNKNOWN_ALGORITHM",
                Self::Rsa => "RSA",
                Self::EccSecp256r1 => "ECC_SECP256R1",
                Self::EccSecp384r1 => "ECC_SECP384R1",
                Self::EccSecp521r1 => "ECC_SECP521R1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_ALGORITHM" => Some(Self::UnknownAlgorithm),
                "RSA" => Some(Self::Rsa),
                "ECC_SECP256R1" => Some(Self::EccSecp256r1),
                "ECC_SECP384R1" => Some(Self::EccSecp384r1),
                "ECC_SECP521R1" => Some(Self::EccSecp521r1),
                _ => None,
            }
        }
    }
}
/// DrmCertificate signed by a higher (CA) DRM certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedDrmCertificate {
    /// Serialized certificate. Required.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub drm_certificate: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Signature of certificate. Signed with root or intermediate
    /// certificate specified below. Required.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// SignedDrmCertificate used to sign this certificate.
    #[prost(message, optional, boxed, tag = "3")]
    pub signer: ::core::option::Option<::prost::alloc::boxed::Box<SignedDrmCertificate>>,
    /// Optional field that indicates the hash algorithm used in signature scheme.
    #[prost(enumeration = "HashAlgorithmProto", optional, tag = "4")]
    pub hash_algorithm: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidevinePsshData {
    /// Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
    /// PSSHs. May be repeated to facilitate delivery of multiple keys in a
    /// single license. Cannot be used in conjunction with content_id or
    /// group_ids, which are the preferred mechanism.
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub key_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Content identifier which may map to multiple entitlement or content key
    /// IDs to facilitate the delivery of multiple keys in a single license.
    /// Cannot be present in conjunction with key_ids, but if used must be in all
    /// PSSHs.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub content_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Crypto period index, for media using key rotation. Always corresponds to
    /// The content key period. This means that if using entitlement licensing
    /// the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
    /// the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
    /// key rotation.
    #[prost(uint32, optional, tag = "7")]
    pub crypto_period_index: ::core::option::Option<u32>,
    /// Protection scheme identifying the encryption algorithm. The protection
    /// scheme is represented as a uint32 value. The uint32 contains 4 bytes each
    /// representing a single ascii character in one of the 4CC protection scheme
    /// values. To be deprecated in favor of signaling from content.
    /// 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
    /// 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
    /// 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
    /// 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
    #[prost(uint32, optional, tag = "9")]
    pub protection_scheme: ::core::option::Option<u32>,
    /// Optional. For media using key rotation, this represents the duration
    /// of each crypto period in seconds.
    #[prost(uint32, optional, tag = "10")]
    pub crypto_period_seconds: ::core::option::Option<u32>,
    /// Type of PSSH. Required if not SINGLE.
    #[prost(
        enumeration = "widevine_pssh_data::Type",
        optional,
        tag = "11",
        default = "Single"
    )]
    pub r#type: ::core::option::Option<i32>,
    /// Key sequence for Widevine-managed keys. Optional.
    #[prost(uint32, optional, tag = "12")]
    pub key_sequence: ::core::option::Option<u32>,
    /// Group identifiers for all groups to which the content belongs. This can
    /// be used to deliver licenses to unlock multiple titles / channels.
    /// Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
    /// not in conjunction with key_ids.
    #[prost(bytes = "vec", repeated, tag = "13")]
    pub group_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Copy/copies of the content key used to decrypt the media stream in which
    /// the PSSH box is embedded, each wrapped with a different entitlement key.
    /// May also contain sub-licenses to support devices with OEMCrypto 13 or
    /// older. May be repeated if using group entitlement keys. Present only in
    /// PSSHs of type ENTITLED_KEY.
    #[prost(message, repeated, tag = "14")]
    pub entitled_keys: ::prost::alloc::vec::Vec<widevine_pssh_data::EntitledKey>,
    /// Video feature identifier, which is used in conjunction with |content_id|
    /// to determine the set of keys to be returned in the license. Cannot be
    /// present in conjunction with |key_ids|.
    /// Current values are "HDR".
    #[prost(string, optional, tag = "15")]
    pub video_feature: ::core::option::Option<::prost::alloc::string::String>,
    #[deprecated]
    #[prost(enumeration = "widevine_pssh_data::Algorithm", optional, tag = "1")]
    pub algorithm: ::core::option::Option<i32>,
    /// Content provider name.
    #[deprecated]
    #[prost(string, optional, tag = "3")]
    pub provider: ::core::option::Option<::prost::alloc::string::String>,
    /// Track type. Acceptable values are SD, HD and AUDIO. Used to
    /// differentiate content keys used by an asset.
    #[deprecated]
    #[prost(string, optional, tag = "5")]
    pub track_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The name of a registered policy to be used for this asset.
    #[deprecated]
    #[prost(string, optional, tag = "6")]
    pub policy: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional protected context for group content. The grouped_license is a
    /// serialized SignedMessage.
    #[deprecated]
    #[prost(bytes = "vec", optional, tag = "8")]
    pub grouped_license: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `WidevinePsshData`.
pub mod widevine_pssh_data {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EntitledKey {
        /// ID of entitlement key used for wrapping |key|.
        #[prost(bytes = "vec", optional, tag = "1")]
        pub entitlement_key_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        /// ID of the entitled key.
        #[prost(bytes = "vec", optional, tag = "2")]
        pub key_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        /// Wrapped key. Required.
        #[prost(bytes = "vec", optional, tag = "3")]
        pub key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        /// IV used for wrapping |key|. Required.
        #[prost(bytes = "vec", optional, tag = "4")]
        pub iv: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        /// Size of entitlement key used for wrapping |key|.
        #[prost(uint32, optional, tag = "5", default = "32")]
        pub entitlement_key_size_bytes: ::core::option::Option<u32>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Single PSSH to be used to retrieve content keys.
        Single = 0,
        /// Primary PSSH used to retrieve entitlement keys.
        Entitlement = 1,
        /// Secondary PSSH containing entitled key(s).
        EntitledKey = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Single => "SINGLE",
                Self::Entitlement => "ENTITLEMENT",
                Self::EntitledKey => "ENTITLED_KEY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SINGLE" => Some(Self::Single),
                "ENTITLEMENT" => Some(Self::Entitlement),
                "ENTITLED_KEY" => Some(Self::EntitledKey),
                _ => None,
            }
        }
    }
    /// //////////////////////////  Deprecated Fields  ////////////////////////////
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Algorithm {
        Unencrypted = 0,
        Aesctr = 1,
    }
    impl Algorithm {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unencrypted => "UNENCRYPTED",
                Self::Aesctr => "AESCTR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNENCRYPTED" => Some(Self::Unencrypted),
                "AESCTR" => Some(Self::Aesctr),
                _ => None,
            }
        }
    }
}
/// File Hashes for Verified Media Path (VMP) support.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileHashes {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub signer: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<file_hashes::Signature>,
}
/// Nested message and enum types in `FileHashes`.
pub mod file_hashes {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Signature {
        #[prost(string, optional, tag = "1")]
        pub filename: ::core::option::Option<::prost::alloc::string::String>,
        /// 0 - release, 1 - testing
        #[prost(bool, optional, tag = "2")]
        pub test_signing: ::core::option::Option<bool>,
        #[prost(bytes = "vec", optional, tag = "3")]
        pub sha512_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        /// 0 for dlls, 1 for exe, this is field 3 in file
        #[prost(bool, optional, tag = "4")]
        pub main_exe: ::core::option::Option<bool>,
        #[prost(bytes = "vec", optional, tag = "5")]
        pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LicenseType {
    Streaming = 1,
    Offline = 2,
    /// License type decision is left to provider.
    Automatic = 3,
}
impl LicenseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Streaming => "STREAMING",
            Self::Offline => "OFFLINE",
            Self::Automatic => "AUTOMATIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAMING" => Some(Self::Streaming),
            "OFFLINE" => Some(Self::Offline),
            "AUTOMATIC" => Some(Self::Automatic),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlatformVerificationStatus {
    /// The platform is not verified.
    PlatformUnverified = 0,
    /// Tampering detected on the platform.
    PlatformTampered = 1,
    /// The platform has been verified by means of software.
    PlatformSoftwareVerified = 2,
    /// The platform has been verified by means of hardware (e.g. secure boot).
    PlatformHardwareVerified = 3,
    /// Platform verification was not performed.
    PlatformNoVerification = 4,
    /// Platform and secure storage capability have been verified by means of
    /// software.
    PlatformSecureStorageSoftwareVerified = 5,
}
impl PlatformVerificationStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PlatformUnverified => "PLATFORM_UNVERIFIED",
            Self::PlatformTampered => "PLATFORM_TAMPERED",
            Self::PlatformSoftwareVerified => "PLATFORM_SOFTWARE_VERIFIED",
            Self::PlatformHardwareVerified => "PLATFORM_HARDWARE_VERIFIED",
            Self::PlatformNoVerification => "PLATFORM_NO_VERIFICATION",
            Self::PlatformSecureStorageSoftwareVerified => {
                "PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLATFORM_UNVERIFIED" => Some(Self::PlatformUnverified),
            "PLATFORM_TAMPERED" => Some(Self::PlatformTampered),
            "PLATFORM_SOFTWARE_VERIFIED" => Some(Self::PlatformSoftwareVerified),
            "PLATFORM_HARDWARE_VERIFIED" => Some(Self::PlatformHardwareVerified),
            "PLATFORM_NO_VERIFICATION" => Some(Self::PlatformNoVerification),
            "PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED" => {
                Some(Self::PlatformSecureStorageSoftwareVerified)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtocolVersion {
    Version20 = 20,
    Version21 = 21,
    Version22 = 22,
}
impl ProtocolVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Version20 => "VERSION_2_0",
            Self::Version21 => "VERSION_2_1",
            Self::Version22 => "VERSION_2_2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERSION_2_0" => Some(Self::Version20),
            "VERSION_2_1" => Some(Self::Version21),
            "VERSION_2_2" => Some(Self::Version22),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashAlgorithmProto {
    /// Unspecified hash algorithm: SHA_256 shall be used for ECC based algorithms
    /// and SHA_1 shall be used otherwise.
    HashAlgorithmUnspecified = 0,
    HashAlgorithmSha1 = 1,
    HashAlgorithmSha256 = 2,
    HashAlgorithmSha384 = 3,
}
impl HashAlgorithmProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HashAlgorithmUnspecified => "HASH_ALGORITHM_UNSPECIFIED",
            Self::HashAlgorithmSha1 => "HASH_ALGORITHM_SHA_1",
            Self::HashAlgorithmSha256 => "HASH_ALGORITHM_SHA_256",
            Self::HashAlgorithmSha384 => "HASH_ALGORITHM_SHA_384",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HASH_ALGORITHM_UNSPECIFIED" => Some(Self::HashAlgorithmUnspecified),
            "HASH_ALGORITHM_SHA_1" => Some(Self::HashAlgorithmSha1),
            "HASH_ALGORITHM_SHA_256" => Some(Self::HashAlgorithmSha256),
            "HASH_ALGORITHM_SHA_384" => Some(Self::HashAlgorithmSha384),
            _ => None,
        }
    }
}
